```
오전: 
오후:
- ㄷㅎ 강사님께 junit 사용해서, 단위테스트를 잘하는 것이 제일 중요하다. 
```

### 한마디
>지원과정_(순번)_이름_문서유형_.pdf 디렉토리 나눠서 
정성을 들여야 하는 일이 있다면, 
같지 않은 참여자들이 있다면, 애티튜드를 고민해보자. 

실습 자료로 돌려보고 -> 정독 -> 직접 타이핑 -> 책 안보고 해보기(키워드 적어놓고,)
- 머리속의 개념 가지고 직접 해보기 
- 처음부터 타이핑 하면 --> 동작하는걸 한번 보고 하면 이걸 안다. 
- jpa로 잘 녹여내는 것
- 화면으로 매핑하다보면, 조회용 테이블로 빼야하는구나. 화면도 바뀌고, 시나리오도 바뀜
 
 지나치게 디버깅에 의존해선 안되는데, 디버깅 최소화하려면 단위테스트 많이 해볼것 
 한 페이지 보다가.. 호출? 단어로부터 시작해서, 연관고리를 계속 만들어서 가기.. 
 mysql같은 경우는...pc에 각자 설치해서 
13일 client 툴.. 맥북으로도
aws 각자 만들고, 화면 떠서 신용카드 등록해야함. 한달간은 프리티어는 쓰실 수 있음. 


## Maven
```
- 의존성 관리
    - library
- Tag 식별
```
1. Java
1999 - write once run every where
- 가상화라는 기술의 첫번째 산출물 중 하나. 
- java -> bytecode -> JRE(윈도우/맥/유닉스 버전: 동일하게 동작)

1) JVM
2) 기업 Language -> JCP (웹개발에 필요한 Spec 정의함) 
 - 기능에 대한 명세를 정의
 J2EE -> JavaEE -> JakrtaEE 
 - 구현하는것을 참조 구현체 : 공식적 Tomcat
   - 대부분의 개발자는 Sun 개발자 

1. pain point
- shell script가 os별 다름
- 검증이 복잡함
2. Java -> 빌드에 사용하는 쉘 cp, javac, mv,rm, tar 등...
- Java class 로 구현해놓고, 다형성으로 만들어서 호출하고, 빌드 스크립트를 만들면 
하나만 개발해놓으면 모든 운영체제에서 동작하는 것 아닐까? 
> ?- 각각의 운영체제에서 쓸 수 있는, 쉘 스크립트에 대한 것을 자바로 구현해서 빌드 프로그램을 만들어보자!
- java로 빌드 기능 추상화
  - 디자인패턴 (리눅스라면, x86, arm이라면.. 실제 운영체제에서는 어떤 명령을 호출해라.)
  - 런타임을 만들고, 실제 스크립트는 자바가 아닌 다른 코드를 만들면 어떨까? 2000년 초반
  - `xml` : web.xml 로 만들어야 함. 
  - 스프링부트: annotation
- 기존의 shell을 자바레벨에서 -> 직접적으로 관리할 수 있게 xml로 만듦

### Ant의 장점
1. OS의 다양x
2. XML 가독성이 좋다. 평문
- Ant의 빌드 스크립트는 XML 파일(보통 build.xml 파일)에 정의됩니다.
- 빌드 스크립트는 프로젝트의 빌드 프로세스를 정의하는 일련의 타겟(target)과 태스크(task)로 구성됩니다.
- `타겟 및 태스크`
  - 타겟(Target): 빌드 프로세스의 논리적인 단위로, 예를 들어 컴파일, 테스트, 배포 등의 작업이 타겟에 해당합니다.
  - 태스크(Task): 각 타겟 내에서 수행되는 개별 작업으로, 예를 들어 파일 복사, 컴파일, 아카이빙 등의 작업을 포함합니다.
- `플랫폼 독립적`
  - 자바로 작성되어 플랫폼에 독립적이며, 다양한 운영 체제에서 동일하게 작동합니다.
- `유연성`
  - 사용자 정의 태스크를 작성할 수 있으며, 다양한 태스크를 지원하여 빌드 프로세스를 유연하게 구성할 수 있습니다.
  - 여러 타겟 간의 의존성을 정의할 수 있어 빌드 순서를 자동으로 관리합니다.
- `확장 가능`
  - Ant는 자체 태스크를 확장할 수 있으며, 자바 클래스나 스크립트를 통해 새로운 기능을 추가할 수 있습니다.

### Ant 단점
1. Build process -> 하나가 잘못되면 연쇄적으로 잘못됨
  - Build xml -> 5,000 line 이상 
- 장점: 자유도 , 추상화
- 단점: 이해하기 어려움(개선점 필요) 
  - pain point : `표준화` -> Maven -> POM(Project Obejct Model)
2. 빌드에만 초점, 라이브러리 미흡
  - 레포지터리에 대한 개념을 넣고, 라이브러리들을 모일 수 있게 구성 
    - 내부 의존성을 확장
    - 디렉토리 관리하는 구조 개선(파악하는 수고x), -> 프로젝트를 표준화시켜서 심플하게
    - 이해하고 활용하는 데 쉬워짐 --> 그때그때 자동으로 만들어짐 
    - library가 프로젝트와 이탈하게 되면서, 프로젝트의 모든 코드: plain text (일반평문)-> 관리하기 간단해짐 
    - Maven으로 빌드하는 게 쉬워짐 

### Maven이란
- 
- it 대부분의 기술: 정반합
  - 정ant : xml 태그 표현 미흡, 지나치게 표준화해서 커스터마이징이 어려움, 가독성 떨어짐
  - 라이브러리 관리 체계 구조는 그대로 가져가자. --> maven에서 gradle로 넘어감 
- Maven은 중앙 저장소를 통한 자동 의존성 관리(회사내 사용 저장
소도 구성 가능)
- Maven이 히트를 친 건, pom.xml에 필요한 라이브러리를 정의해
놓으면 내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가
작동하는데 필요한 다른 라이브러리들까지 자동으로 다운받아줘
서 의존성을 관리해주기 때문.
### Maven 장점
- 라이브러리 관리가 쉽다.
- 프로젝트의 작성부터 컴파일, 테스트 프로젝트 라이프사이클에 포
함된 각 테스트를 지원.
- 빌드 과정을 쉽게 만들어 줌.

### POM
1) 의존성 라이브러리 
2) repositories 다운로드 
3) 프로젝트 라이프사이클 
  - 소스코드를 변형
    - ex) 한글로 된거 컴파일이 잘 안될 수 있음/utf-8, 아스키 코드로 변환시키는 등 
  - generated files
    - xml로 만들고, 컴파일 전에, java로 만들어라 등 
  - Resource
    - 자바 이외의 것
  - Binaries
  - Packaged libraries 

- artifact: 그 group에서 만든 산출물
- gradle : xml이 아니라, implementation group: 쓰는 방식이 달라졌을 뿐이다. 
- gradle: 코틀린문법, 축약버전도 있다., 
- SBT: 스칼라. 
  - java가 만들어짐 
  - 내부 명사: 클래스 
    - 명사를 이용해서 구체적인 데이터의 흐름을 정의 : `OOP`
  - 동사 중심
    - input이 들어가면, 내부적으로만 처리하고, 하나의 output으로 귀결된다. `function(함수)`
    - 외부적인 영향은 최소화시키자. 
- 사람은 외부적인것 영향을 받음. 
  - 내부적 요소만 통제 안됨. 
- 함수형 언어는 철저하게 logic 안에서 input 들어오면, 외부에 대한 접근이 절대 불가하다. 
- 공개되어 있는, static variable에 대한 것이 없다. 
- 시뮬레이션 하기도 편하고 장점이 많다. 
- 외부와의 관계가 없을 수 있다. 
-> OOP + functional --> Scala
- Kafka, Spark 대용량 시스템, 실시간 처리 시스템 --> 스칼라로 개발(문법 복잡) 
- Ivy: ant에서 사용 
> ? ant -> maven -> ant+Ivy -> gradle

